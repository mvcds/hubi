# Hubi [![Build Status](https://travis-ci.org/mvcds/hubi.svg?branch=master)](https://travis-ci.org/mvcds/hubi) [![JavaScript Style Guide](https://img.shields.io/badge/code_style-standard-brightgreen.svg)](https://standardjs.com) [![Coverage Status](https://coveralls.io/repos/github/mvcds/hubi/badge.svg?branch=master)](https://coveralls.io/github/mvcds/hubi?branch=master) [![GitHub license](https://img.shields.io/github/license/mvcds/hubi.svg?style=flat-square)](https://github.com/mvcds/hubi/blob/master/LICENSE)

> Teach `hubi` your [ubiquitous language](https://martinfowler.com/bliki/UbiquitousLanguage.html) and it will write relevant source files for you

The humanitarian ubiquitous language helper, or `hubi` for short, reads some of your files and learns the ubiquitous language behind your domain. With that knowledge, it writes source files for you, so you don't have to.

<img src="./assets/hubi.gif" alt="how to use hubi" title="how to use hubi" />

## How to use it

### Use Case (example)

Imagine you are assigned to the task of showing the custumer's birthday on its profile page. Here is a list of possible places you'd need to change within an imaginary JS stack in order to accomplish it (your stack may be a little different):

* Back-end repository
  - Sequelize Model
  - Domain schema
  - GraphQL type
  - Fixture factory
* Front-end repository
  - GraphQL query
  - Domain model
  - Prop Types
  - Fixture factory (in an ideal world it would be shared with its back-end repository, but here is not)
* Othere repository where the new data is relevant
  - C# class
  - ...
* ...

Instead of updating each item individually, you could use `hubi` to automate writing your code: [Joi Schemas](https://github.com/mvcds/hubi/issues/17), [Sequelize Models](https://github.com/mvcds/hubi/issues/26), [GraphQL types](https://github.com/mvcds/hubi/issues/27), [C# classes](https://github.com/mvcds/hubi/issues/28), etc.

### 1. Install

> As `hubi` is a developing tool, it is recommended that each project have it installed by using the developer flag.

```
& npm i hubi --save-dev
```

### 2. Define your ubiquitous language

Create a YAML file, refered to as [domain file](https://mvcds.github.io/hubi/#domain-file), which configures some rules to create your source files. You can learn them at `hubi`'s [domain file guide :green_book:](./docs/domain-file-guide.md).

```yaml
# src/domain/entities/user.yml
name: User
description: A person who has an account
attributes:
  - name: name
    description: How to address the person
    required: true
  - name: birthday
    comment: This field was added later
    type: date
    required: false
```

### 3. Watch some magic

Add an npm script into your `package.json`, to facilitate running `hubi`:

```json
{
  ...
  "build:hubi": "npm run hubi:joi && npm run hubi:site",
  "hubi:joi": "hubi save --same-folder --translator joi",
  "hubi:site": "hubi save --output documents --translator site"
  ...
}
```

After calling the command below, you are going to have your user-related source files updated.

```shell
& npm run build:hubi
npm run hubi:joi & npm run hubi:site
node hubi save --same-folder --translator joi
node hubi hubi save --output documents --translator site
```

Using the previous domain file as part of our example:

* `build:hubi` will run `hubi:joi` and `hubi:site`
* `hubi:joi` will create a `src/domain/entities/user.joi.js` file
* `hubi:site` will create a `documents/index.hubi.html` file which is your ubiquitous language documented as part of a site which may be exposed to stackholders

## CLI

At the moment, `hubi` can only be used via command line, and thus you can script upon it.

### help

Show the commands bellow

### log

Logs the ubiquitous language entities to the console, in order to allow you to read it before saving it

* `--pattern | -p` is a glob pattern to your domain files, defaults to `src/**/*.yml`
* `--translator | -t` which [translator](https://mvcds.github.io/hubi/#translator) will be use to put the domain files into the console, defaults to `log`
* `--verbose | -v` which allows debugging

>  :warning: At the moment we partially support two **real** [translators](https://mvcds.github.io/hubi/#translator), `site` or `joi`. But you can also play with `ubi` and `log` which served as proof of concept to `hubi`.

### save

Saves the ubiquitous language entities into source files, the whole point of this project!

* the same arguments as `log`, plus
* `--output | -o` is the folder to which files will be saved, defaults to `domain`
* `--same-folder | -s` overides the output flag, by geneating the source file on the same folder as the token's domain file.

## More

### Dogfood

The term is used by technologies (ideas, products, etc) used by their own makers, here are some ways `hubi` dogfoods:

* [`hubi`'s doc site](https://mvcds.github.io/hubi#all) is generated by `hubi` itself
* The Domain File's YAML is a [sample](src/Domain/Entities/UbiquitousToken/domain-file.yml) of a domain file
* The source files `hubi` has generated are [imported into](https://github.com/mvcds/hubi/blob/523eb385e8f950224ee7791c8fd4edb47986ee4c/src/Domain/Objects/AttributeParser/Attributes/Attribute.js#L3) non-automatized source files i.e. we're using what we've done!

### Contributing

Take a look at our [:green_book: contributing guide](CONTRIBUTING.md) to a more complete version of this section.

#### With no code

Staring the project is an amazing help :star:, as well as fork it and talking to your peers about it.

We are also looking for ideas to improve `hubi`, so submiting bug reports, showcases, and clearer documentation & feature requests, are more than welcome.

Non-code-related stuff, as logos and translations, are needed to.

### With some code

This project relies on [useful Translators](https://github.com/mvcds/hubi/projects/2), so feel free to create your owns and open PRs about it.

We'd also like to improve the [HTML generated by the site translator](https://github.com/mvcds/hubi/issues/35) and add some functionalities on top of it.

### For those who don't know/use [domain-driven design [DDD]](https://airbrake.io/blog/software-design/domain-driven-design)

I don’t know if Eric Evans, the author of domain-driven design book, coined the term “ubiquitous language” or if he only used it as his books' initial seed. But I see *the-language-to-rule-them-all* as a communication tool that simply states that we should encode domain knowledge (terms, phrases, etc) into the codebase in order to bridge the gap between developers and domain experts.

But you can still use ubiquitous language regardless of DDD because it stands on its own. So, even if you don't know/use DDD you can still use `hubi` to reap the benefits of speaking a single language - at the same time you [document your code](https://developers.redhat.com/blog/2017/06/21/documentation-as-code/).

### Should I pronounce the "h"?

No. The package name was supposed to be "ubi" (as in ubiquitous) but the name was already taken on npm, so I've used the only mute letter we have in Portuguese.

By pronouncing the "h" most Brazilians will never understand if you're referring to the Ruby programming language or this project. That sound ~~in that position~~ is not natural for us, so most of us simply can't tell "rot" and "hot", or "ruby" and "hubi", apart, for instance.
